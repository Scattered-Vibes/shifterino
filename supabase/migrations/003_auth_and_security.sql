-- 003_auth_and_security.sql
--
-- This migration handles authentication, session management, and security aspects:
--  - Tables for auth.sessions, auth.refresh_tokens, auth.mfa_amr_claims, auth.secrets
--  - RLS policies
--  - Rate limiting setup
--  - Audit logging configurations
-- Auth Sessions & Related Tables
CREATE TABLE IF NOT EXISTS auth.sessions (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamptz,
    refreshed_at timestamp,
    user_agent text,
    ip inet,
    tag text
);

CREATE TABLE IF NOT EXISTS auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    token character varying(255),
    user_id character varying(255),
    revoked boolean DEFAULT false,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),
    parent character varying(255),
    session_id uuid
);

CREATE TABLE IF NOT EXISTS auth.mfa_amr_claims (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id uuid,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    authentication_method text NOT NULL,
    CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method)
);

-- AAL Level type setup
DO $$ BEGIN 
    CREATE TYPE auth.aal_level AS ENUM ('aal1', 'aal2', 'aal3');
EXCEPTION 
    WHEN duplicate_object THEN null;
END $$;

-- Triggers for `updated_at` columns in auth schema
DROP TRIGGER IF EXISTS update_sessions_updated_at ON auth.sessions;

CREATE TRIGGER update_sessions_updated_at 
    BEFORE UPDATE ON auth.sessions 
    FOR EACH ROW 
    EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_refresh_tokens_updated_at ON auth.refresh_tokens;

CREATE TRIGGER update_refresh_tokens_updated_at BEFORE
UPDATE
    ON auth.refresh_tokens FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_mfa_amr_claims_updated_at ON auth.mfa_amr_claims;

CREATE TRIGGER update_mfa_amr_claims_updated_at BEFORE
UPDATE
    ON auth.mfa_amr_claims FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Enable RLS on auth tables
ALTER TABLE
    auth.sessions ENABLE ROW LEVEL SECURITY;

ALTER TABLE
    auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

ALTER TABLE
    auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

-- JWT Secrets & Configuration
CREATE TABLE IF NOT EXISTS auth.secrets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL UNIQUE,
    secret text NOT NULL,
    key_id uuid NOT NULL DEFAULT gen_random_uuid(),
    key_salt text,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Permissions for auth.secrets
GRANT ALL ON auth.secrets TO supabase_auth_admin;

GRANT
SELECT
    ON auth.secrets TO authenticator;

DROP TRIGGER IF EXISTS update_secrets_updated_at ON auth.secrets;

CREATE TRIGGER update_secrets_updated_at BEFORE
UPDATE
    ON auth.secrets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- JWT Helper Functions
CREATE OR REPLACE FUNCTION auth.jwt() 
RETURNS jsonb 
LANGUAGE sql 
STABLE 
AS $$
    SELECT coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb;
$$;

CREATE OR REPLACE FUNCTION auth.role() 
RETURNS text 
LANGUAGE sql 
STABLE 
AS $$
    SELECT coalesce(
        nullif(current_setting('request.jwt.claim.role', true), ''),
        nullif(current_setting('request.jwt.claims.role', true), '')
    )::text;
$$;

-- Grant Permissions for JWT Functions
GRANT EXECUTE ON FUNCTION auth.jwt() TO anon,
authenticated,
service_role;

GRANT EXECUTE ON FUNCTION auth.role() TO anon,
authenticated,
service_role;

-- RLS Policies
-- Helper function to check if user is manager
CREATE OR REPLACE FUNCTION public.is_manager() 
RETURNS boolean 
AS $$
BEGIN 
    RETURN EXISTS (
        SELECT 1
        FROM public.employees
        WHERE auth_id = auth.uid()
        AND role = 'manager'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if user is supervisor or above
CREATE OR REPLACE FUNCTION public.is_supervisor_or_above() 
RETURNS boolean 
AS $$
BEGIN 
    RETURN EXISTS (
        SELECT 1
        FROM public.employees
        WHERE auth_id = auth.uid()
        AND role IN ('supervisor', 'manager')
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to get user's team members (for supervisors)
CREATE OR REPLACE FUNCTION public.get_team_members() 
RETURNS TABLE (employee_id uuid) 
AS $$
BEGIN 
    RETURN QUERY
    SELECT e.id
    FROM public.employees e
    WHERE EXISTS (
        SELECT 1
        FROM public.employees supervisor
        WHERE supervisor.auth_id = auth.uid()
        AND supervisor.role IN ('supervisor', 'manager')
        AND e.team_id = supervisor.team_id
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Enable RLS on all tables
ALTER TABLE public.employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.individual_shifts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.time_off_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shift_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.staffing_requirements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.schedule_periods ENABLE ROW LEVEL SECURITY;
-- schedules table RLS is enabled in 001_initial_schema.sql
ALTER TABLE public.scheduling_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shift_assignment_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.system_settings ENABLE ROW LEVEL SECURITY;
-- test_data table RLS is enabled in 004_test_helpers_setup.sql

-- Employees table policies
CREATE POLICY "employees_select_own" ON public.employees FOR
SELECT
    USING (auth_id = auth.uid());

CREATE POLICY "employees_select_supervisor" ON public.employees FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "employees_all_manager" ON public.employees FOR ALL USING (is_manager());

-- Profiles table policies
CREATE POLICY "profiles_select_own" ON public.profiles FOR
SELECT
    USING (id = auth.uid());

CREATE POLICY "profiles_update_own" ON public.profiles FOR
UPDATE
    USING (id = auth.uid()) WITH CHECK (id = auth.uid());

CREATE POLICY "profiles_select_supervisor" ON public.profiles FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND id IN (
            SELECT
                auth_id
            FROM
                public.employees
            WHERE
                id IN (
                    SELECT
                        employee_id
                    FROM
                        public.get_team_members()
                )
        )
    );

CREATE POLICY "profiles_all_manager" ON public.profiles FOR ALL USING (is_manager());

-- Individual shifts table policies
CREATE POLICY "shifts_select_own" ON public.individual_shifts FOR
SELECT
    USING (
        employee_id IN (
            SELECT id
            FROM public.employees
            WHERE auth_id = auth.uid()
        )
    );

CREATE POLICY "shifts_update_own" ON public.individual_shifts
    FOR UPDATE 
    USING (
        employee_id IN (
            SELECT id 
            FROM public.employees 
            WHERE auth_id = auth.uid()
        )
    )
    WITH CHECK (
        employee_id IN (
            SELECT id 
            FROM public.employees 
            WHERE auth_id = auth.uid()
        )
        -- Only allow updating actual times
        AND EXISTS (
            SELECT 1
            FROM public.individual_shifts existing
            WHERE existing.id = individual_shifts.id
            AND (
                individual_shifts.actual_start_time IS DISTINCT FROM existing.actual_start_time
                OR individual_shifts.actual_end_time IS DISTINCT FROM existing.actual_end_time
            )
            -- Don't allow modifying other fields
            AND individual_shifts.employee_id = existing.employee_id
            AND individual_shifts.shift_option_id = existing.shift_option_id
            AND individual_shifts.schedule_period_id = existing.schedule_period_id
            AND individual_shifts.date = existing.date
            AND individual_shifts.status = existing.status
            AND individual_shifts.is_overtime = existing.is_overtime
            AND individual_shifts.is_regular_schedule = existing.is_regular_schedule
        )
    );

CREATE POLICY "shifts_select_supervisor" ON public.individual_shifts FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "shifts_update_supervisor" ON public.individual_shifts FOR
UPDATE
    USING (
        is_supervisor_or_above()
        AND employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    ) WITH CHECK (
        employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "shifts_all_manager" ON public.individual_shifts FOR ALL USING (is_manager());

-- Time off requests table policies
CREATE POLICY "time_off_select_own" ON public.time_off_requests FOR
SELECT
    USING (
        employee_id IN (
            SELECT
                id
            FROM
                public.employees
            WHERE
                auth_id = auth.uid()
        )
    );

CREATE POLICY "time_off_insert_own" ON public.time_off_requests FOR
INSERT
    WITH CHECK (
        employee_id IN (
            SELECT
                id
            FROM
                public.employees
            WHERE
                auth_id = auth.uid()
        )
    );

CREATE POLICY "time_off_update_own" ON public.time_off_requests FOR
UPDATE
    USING (
        employee_id IN (
            SELECT id
            FROM public.employees
            WHERE auth_id = auth.uid()
        )
        AND status = 'pending'
    ) WITH CHECK (
        employee_id IN (
            SELECT id
            FROM public.employees
            WHERE auth_id = auth.uid()
        )
        AND EXISTS (
            SELECT 1
            FROM public.time_off_requests existing
            WHERE existing.id = time_off_requests.id
            -- Don't allow modifying status
            AND time_off_requests.status = existing.status
            -- Ensure other fields match
            AND time_off_requests.employee_id = existing.employee_id
            AND time_off_requests.start_date = existing.start_date
            AND time_off_requests.end_date = existing.end_date
            AND time_off_requests.notes = existing.notes
            AND time_off_requests.reason = existing.reason
        )
    );

CREATE POLICY "time_off_delete_own" ON public.time_off_requests FOR DELETE USING (
    employee_id IN (
        SELECT
            id
        FROM
            public.employees
        WHERE
            auth_id = auth.uid()
    )
    AND status = 'pending'
);

CREATE POLICY "time_off_select_supervisor" ON public.time_off_requests FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "time_off_update_supervisor" ON public.time_off_requests FOR
UPDATE
    USING (
        is_supervisor_or_above()
        AND employee_id IN (
            SELECT employee_id
            FROM public.get_team_members()
        )
    ) WITH CHECK (
        employee_id IN (
            SELECT employee_id
            FROM public.get_team_members()
        )
        AND EXISTS (
            SELECT 1
            FROM public.time_off_requests existing
            WHERE existing.id = time_off_requests.id
            -- Only allow updating status to approved or rejected
            AND time_off_requests.status IS DISTINCT FROM existing.status
            AND time_off_requests.status IN ('approved', 'rejected')
            -- Don't allow modifying other fields
            AND time_off_requests.start_date = existing.start_date
            AND time_off_requests.end_date = existing.end_date
            AND time_off_requests.reason = existing.reason
            AND time_off_requests.employee_id = existing.employee_id
        )
    );

CREATE POLICY "time_off_all_manager" ON public.time_off_requests FOR ALL USING (is_manager());

-- Shift options policies (reference data)
CREATE POLICY "shift_options_read_authenticated" ON public.shift_options FOR
SELECT
    TO authenticated USING (true);

CREATE POLICY "shift_options_all_manager" ON public.shift_options FOR ALL USING (is_manager());

-- Staffing requirements policies
CREATE POLICY "staffing_requirements_read_authenticated" ON public.staffing_requirements FOR
SELECT
    TO authenticated USING (true);

CREATE POLICY "staffing_requirements_all_manager" ON public.staffing_requirements FOR ALL USING (is_manager());

-- Schedule periods policies
CREATE POLICY "schedule_periods_read_authenticated" ON public.schedule_periods FOR
SELECT
    TO authenticated USING (true);

CREATE POLICY "schedule_periods_all_manager" ON public.schedule_periods FOR ALL USING (is_manager());

-- Schedules policies
CREATE POLICY "schedules_select_own" ON public.schedules FOR
SELECT
    USING (
        employee_id IN (
            SELECT
                id
            FROM
                public.employees
            WHERE
                auth_id = auth.uid()
        )
    );

CREATE POLICY "schedules_select_supervisor" ON public.schedules FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "schedules_all_manager" ON public.schedules FOR ALL USING (is_manager());

-- Scheduling logs policies (audit trail)
CREATE POLICY "scheduling_logs_select_own" ON public.scheduling_logs FOR
SELECT
    USING (
        related_employee_id IN (
            SELECT
                id
            FROM
                public.employees
            WHERE
                auth_id = auth.uid()
        )
    );

CREATE POLICY "scheduling_logs_select_supervisor" ON public.scheduling_logs FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND related_employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "scheduling_logs_insert_authenticated" ON public.scheduling_logs FOR
INSERT
    TO authenticated WITH CHECK (true);

CREATE POLICY "scheduling_logs_all_manager" ON public.scheduling_logs FOR ALL USING (is_manager());

-- Shift assignment scores policies
CREATE POLICY "shift_scores_select_supervisor" ON public.shift_assignment_scores FOR
SELECT
    USING (
        is_supervisor_or_above()
        AND employee_id IN (
            SELECT
                employee_id
            FROM
                public.get_team_members()
        )
    );

CREATE POLICY "shift_scores_all_manager" ON public.shift_assignment_scores FOR ALL USING (is_manager());

-- System settings policies (service role only)
CREATE POLICY "system_settings_service_role" ON public.system_settings FOR ALL USING (false);

-- Rate Limiting
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id text PRIMARY KEY,
    count integer NOT NULL DEFAULT 0,
    last_request timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_rate_limits_last_request ON public.rate_limits (last_request);

CREATE INDEX IF NOT EXISTS idx_rate_limits_created_at ON public.rate_limits (created_at);

-- Add RLS policies
ALTER TABLE
    public.rate_limits ENABLE ROW LEVEL SECURITY;

-- Only allow the service role to access this table
CREATE POLICY "service_role_only" ON public.rate_limits FOR ALL TO service_role USING (true);

-- Create a function to cleanup old rate limit records
CREATE OR REPLACE FUNCTION cleanup_rate_limits() 
RETURNS void 
LANGUAGE plpgsql 
SECURITY DEFINER 
AS $$ 
BEGIN
    DELETE FROM public.rate_limits
    WHERE created_at < now() - INTERVAL '1 day';
END;
$$;

-- Create a cron job to cleanup old records daily if pg_cron is available
DO $$ 
BEGIN 
    IF EXISTS (
        SELECT 1
        FROM pg_extension
        WHERE extname = 'pg_cron'
    ) THEN 
        PERFORM cron.schedule(
            'cleanup-rate-limits',
            '0 0 * * *',
            'SELECT cleanup_rate_limits();'
        );
    END IF;
END 
$$;

-- Audit Logging
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    action_type text NOT NULL,
    table_name text NOT NULL,
    record_id uuid NOT NULL,
    changed_by uuid REFERENCES auth.users(id),
    old_values jsonb,
    new_values jsonb,
    created_at timestamptz DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_table_record ON audit_logs (table_name, record_id);

-- Create functions for audit logging
CREATE OR REPLACE FUNCTION log_audit_event() 
RETURNS trigger 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$ 
BEGIN
    INSERT INTO audit_logs (
        table_name,
        record_id,
        action_type,
        old_values,
        new_values,
        changed_by
    )
    VALUES (
        TG_TABLE_NAME,
        CASE
            WHEN TG_OP = 'DELETE' THEN OLD.id
            ELSE NEW.id
        END,
        TG_OP,
        CASE
            WHEN TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN to_jsonb(OLD)
            ELSE NULL
        END,
        CASE
            WHEN TG_OP = 'UPDATE' OR TG_OP = 'INSERT' THEN to_jsonb(NEW)
            ELSE NULL
        END,
        auth.uid()
    );
    RETURN NULL;
END;
$$;

-- Create triggers for audit logging
DROP TRIGGER IF EXISTS audit_individual_shifts ON individual_shifts;

CREATE TRIGGER audit_individual_shifts
AFTER
INSERT
    OR
UPDATE
    OR DELETE ON individual_shifts FOR EACH ROW EXECUTE FUNCTION log_audit_event();

DROP TRIGGER IF EXISTS audit_shift_swap_requests ON shift_swap_requests;

CREATE TRIGGER audit_shift_swap_requests
AFTER
INSERT
    OR
UPDATE
    OR DELETE ON shift_swap_requests FOR EACH ROW EXECUTE FUNCTION log_audit_event();

DROP TRIGGER IF EXISTS audit_on_call_assignments ON on_call_assignments;

CREATE TRIGGER audit_on_call_assignments
AFTER
INSERT
    OR
UPDATE
    OR DELETE ON on_call_assignments FOR EACH ROW EXECUTE FUNCTION log_audit_event();

-- Add audit logging trigger for sensitive operations
CREATE OR REPLACE FUNCTION public.log_sensitive_operations() 
RETURNS trigger 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$ 
DECLARE
    v_employee_id uuid;
    v_record_id uuid;
    v_record_data jsonb;
BEGIN 
    -- Safely get record ID
    v_record_id := CASE
        WHEN TG_OP = 'DELETE' THEN OLD.id
        ELSE NEW.id
    END;

    -- Safely determine employee_id based on table and operation type
    BEGIN
        v_employee_id := CASE
            WHEN TG_OP = 'DELETE' THEN
                CASE
                    WHEN TG_TABLE_NAME = 'employees' THEN OLD.id
                    WHEN TG_TABLE_NAME = 'schedules' THEN
                        CASE 
                            WHEN to_jsonb(OLD) ? 'employee_id' THEN OLD.employee_id
                            ELSE NULL
                        END
                    ELSE NULL
                END
            ELSE
                CASE
                    WHEN TG_TABLE_NAME = 'employees' THEN NEW.id
                    WHEN TG_TABLE_NAME = 'schedules' THEN
                        CASE 
                            WHEN to_jsonb(NEW) ? 'employee_id' THEN NEW.employee_id
                            ELSE NULL
                        END
                    ELSE NULL
                END
        END;
    EXCEPTION WHEN OTHERS THEN
        -- If any error occurs while getting employee_id, set it to NULL
        v_employee_id := NULL;
    END;

    -- Safely get record data
    BEGIN
        v_record_data := CASE TG_OP
            WHEN 'DELETE' THEN jsonb_build_object('old_data', to_jsonb(OLD), 'changed_by', auth.uid())
            WHEN 'UPDATE' THEN jsonb_build_object('old_data', to_jsonb(OLD), 'new_data', to_jsonb(NEW), 'changed_by', auth.uid())
            WHEN 'INSERT' THEN jsonb_build_object('new_data', to_jsonb(NEW), 'created_by', auth.uid())
        END;
    EXCEPTION WHEN OTHERS THEN
        -- If any error occurs while building record data, create a minimal version
        v_record_data := jsonb_build_object('error', 'Failed to serialize record data');
    END;

    IF TG_OP = 'DELETE' THEN
        INSERT INTO scheduling_logs (
            log_message,
            severity,
            related_employee_id,
            created_by
        )
        VALUES (
            format(
                'Operation: %s, Table: %s, Record ID: %s, Details: %s',
                TG_OP,
                TG_TABLE_NAME,
                v_record_id,
                v_record_data::text
            ),
            'warning',
            v_employee_id,
            auth.uid()
        );
        RETURN OLD;
    ELSIF TG_OP = 'UPDATE' THEN
        IF EXISTS (
            SELECT 1
            FROM jsonb_each(to_jsonb(NEW))
            WHERE key NOT IN ('updated_at')
            AND jsonb_extract_path_text(to_jsonb(OLD), key) IS DISTINCT FROM
                jsonb_extract_path_text(to_jsonb(NEW), key)
        ) THEN
            INSERT INTO scheduling_logs (
                log_message,
                severity,
                related_employee_id,
                created_by
            )
            VALUES (
                format(
                    'Operation: %s, Table: %s, Record ID: %s, Details: %s',
                    TG_OP,
                    TG_TABLE_NAME,
                    v_record_id,
                    v_record_data::text
                ),
                'info',
                v_employee_id,
                auth.uid()
            );
        END IF;
        RETURN NEW;
    ELSIF TG_OP = 'INSERT' THEN
        INSERT INTO scheduling_logs (
            log_message,
            severity,
            related_employee_id,
            created_by
        )
        VALUES (
            format(
                'Operation: %s, Table: %s, Record ID: %s, Details: %s',
                TG_OP,
                TG_TABLE_NAME,
                v_record_id,
                v_record_data::text
            ),
            'info',
            v_employee_id,
            auth.uid()
        );
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$;

-- Add audit triggers to sensitive tables
CREATE TRIGGER log_employee_changes
AFTER
INSERT
    OR
UPDATE
    OR DELETE ON public.employees FOR EACH ROW EXECUTE FUNCTION public.log_sensitive_operations();

CREATE TRIGGER log_schedule_changes
AFTER
INSERT
    OR
UPDATE
    OR DELETE ON public.schedules FOR EACH ROW EXECUTE FUNCTION public.log_sensitive_operations();

CREATE TRIGGER log_staffing_requirement_changes
AFTER
INSERT
    OR
UPDATE
    OR DELETE ON public.staffing_requirements FOR EACH ROW EXECUTE FUNCTION public.log_sensitive_operations();