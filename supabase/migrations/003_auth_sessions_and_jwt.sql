-- 003_auth_sessions_and_jwt.sql
-- This migration consolidates Supabase Auth sessions, refresh tokens, MFA claims, 
-- and JWT configuration (including secret management).

--------------------
-- Section 1: AUTH SESSIONS & RELATED TABLES
--------------------
-- Create auth.sessions table
CREATE TABLE IF NOT EXISTS auth.sessions (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamptz,
    refreshed_at timestamp,
    user_agent text,
    ip inet,
    tag text
);

-- Create auth.refresh_tokens table
CREATE TABLE IF NOT EXISTS auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    token character varying(255),
    user_id character varying(255),
    revoked boolean DEFAULT false,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),
    parent character varying(255),
    session_id uuid
);

-- Create auth.mfa_amr_claims table
CREATE TABLE IF NOT EXISTS auth.mfa_amr_claims (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id uuid,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    authentication_method text NOT NULL,
    CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method)
);

-- Create type for AAL levels if doesn't exist
DO $$ BEGIN
    CREATE TYPE auth.aal_level AS ENUM ('aal1', 'aal2', 'aal3');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Triggers for updated_at columns in sessions tables
DROP TRIGGER IF EXISTS update_sessions_updated_at ON auth.sessions;
CREATE TRIGGER update_sessions_updated_at
    BEFORE UPDATE ON auth.sessions
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_refresh_tokens_updated_at ON auth.refresh_tokens;
CREATE TRIGGER update_refresh_tokens_updated_at
    BEFORE UPDATE ON auth.refresh_tokens
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_mfa_amr_claims_updated_at ON auth.mfa_amr_claims;
CREATE TRIGGER update_mfa_amr_claims_updated_at
    BEFORE UPDATE ON auth.mfa_amr_claims
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

-- Enable RLS on these tables
ALTER TABLE auth.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.refresh_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

-- Policies for sessions, refresh tokens, and MFA claims (granting full access to authenticator)
DROP POLICY IF EXISTS "Users can only access own sessions" ON auth.sessions;
CREATE POLICY "Auth service can manage sessions" ON auth.sessions
    FOR ALL TO authenticator
    USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Users can only access own refresh tokens" ON auth.refresh_tokens;
CREATE POLICY "Auth service can manage refresh tokens" ON auth.refresh_tokens
    FOR ALL TO authenticator
    USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Auth service can manage MFA claims" ON auth.mfa_amr_claims;
CREATE POLICY "Auth service can manage MFA claims" ON auth.mfa_amr_claims
    FOR ALL TO authenticator
    USING (true) WITH CHECK (true);

ALTER TABLE auth.refresh_tokens 
    DROP CONSTRAINT IF EXISTS refresh_tokens_session_id_fkey,
    ADD CONSTRAINT refresh_tokens_session_id_fkey 
    FOREIGN KEY (session_id) 
    REFERENCES auth.sessions(id) 
    ON DELETE CASCADE 
    DEFERRABLE INITIALLY DEFERRED;

ALTER TABLE auth.mfa_amr_claims 
    DROP CONSTRAINT IF EXISTS mfa_amr_claims_session_id_fkey,
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey 
    FOREIGN KEY (session_id) 
    REFERENCES auth.sessions(id) 
    ON DELETE CASCADE 
    DEFERRABLE INITIALLY DEFERRED;

ALTER TABLE auth.sessions OWNER TO supabase_auth_admin;
ALTER TABLE auth.refresh_tokens OWNER TO supabase_auth_admin;
ALTER TABLE auth.mfa_amr_claims OWNER TO supabase_auth_admin;

GRANT USAGE ON SCHEMA auth TO service_role, authenticator, anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA auth TO authenticator;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO authenticator;
GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO authenticator;

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth 
    GRANT ALL ON TABLES TO authenticator;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth 
    GRANT ALL ON SEQUENCES TO authenticator;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth 
    GRANT ALL ON ROUTINES TO authenticator;

--------------------
-- Section 2: JWT SECRETS & CONFIGURATION
--------------------
-- Create auth.secrets table for JWT secret management
CREATE TABLE IF NOT EXISTS auth.secrets (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL UNIQUE,
    secret text NOT NULL,
    key_id uuid NOT NULL DEFAULT gen_random_uuid(),
    key_salt text,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

GRANT ALL ON auth.secrets TO supabase_auth_admin;
GRANT SELECT ON auth.secrets TO authenticator;

CREATE OR REPLACE FUNCTION auth.secrets_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS secrets_updated_at ON auth.secrets;
CREATE TRIGGER secrets_updated_at
    BEFORE UPDATE ON auth.secrets
    FOR EACH ROW
    EXECUTE FUNCTION auth.secrets_updated_at();

-- Insert a default JWT secret if none exists
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM auth.secrets WHERE name = 'jwt_secret') THEN
        INSERT INTO auth.secrets (name, secret)
        VALUES ('jwt_secret', encode(extensions.gen_random_bytes(64), 'base64'));
    END IF;
END $$;

-- Create auth.jwt() function to return JWT claims
CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
    SELECT 
        coalesce(
            nullif(current_setting('request.jwt.claim', true), ''),
            nullif(current_setting('request.jwt.claims', true), '')
        )::jsonb;
$$;

-- Create auth.role() function for extracting role claim
CREATE OR REPLACE FUNCTION auth.role() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT 
        coalesce(
            nullif(current_setting('request.jwt.claim.role', true), ''),
            nullif(current_setting('request.jwt.claims.role', true), '')
        )::text;
$$;

GRANT EXECUTE ON FUNCTION auth.jwt() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION auth.role() TO anon, authenticated, service_role;

GRANT USAGE ON SCHEMA extensions TO anon, authenticated, service_role;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA extensions TO anon, authenticated, service_role; 